/*
 * generated by Xtext 2.15.0
 */
package org.xtext.compilateur.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.compilateur.py.Command
import org.xtext.compilateur.py.Commands
import org.xtext.compilateur.py.Definition
import org.xtext.compilateur.py.Input
import org.xtext.compilateur.py.Nop
import org.xtext.compilateur.py.Output
import org.xtext.compilateur.py.Affect
import org.xtext.compilateur.py.Expr
import org.xtext.compilateur.py.ExprSimple

//import SymbolTable.java

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PyGenerator extends AbstractGenerator {

	SymbolTable symtab=SymbolTable.getInstance();
	//VariableTable vartab=new VariableTable();
	Fonction fonction = new Fonction();
	Code3Address code3 = new Code3Address();
//	private int numeroVariable = 0;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context
		
	) {

	}
	
	def doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context, String name_file)
	{
						
		for(r :  resource.allContents.toIterable.filter(Definition))
		{
			fsa.generateFile(name_file,r.compile());
		}

	}

//def compile(Program p, int n){
//	
//}
	def compile(Definition d){
		symtab.addSymbol('read');
		compile(d.input);
		symtab.addSymbol('%');
		compile(d.commands);
		symtab.addSymbol('%');
		symtab.addSymbol('write');
		compile(d.output);
		
		return this.symtab.toString+"\n"+this.code3.toString()+"\n"+fonction.toString() ;
	}
	
	def getSymbTab(){
		return this.symtab;
	}
	
	def getFonction(){
		return this.fonction;
	}
	
	def compile(Input i){
		val size=i.vars.size;
			
		for(var j=0;j<size;j++){
			fonction.addVariable(i.vars.get(j), VarType.input);
		}
//		println(fonction.toString());
		return fonction.toString();	
		
	}
	
	def compile(Commands cs){
		val size=cs.commands.size;
		
		for(var i=0;i<size;i++){
			cs.commands.get(i).compile();
		}
	}
	
	def compile(Output o){
		val size=o.vars.size;
			
		for(var j=0;j<size;j++){
			fonction.addVariable(o.vars.get(j), VarType.output);
		}
		return fonction.affichageVariablesSortie();
	}
	
	def compile(Command c){
		if(c.cmd instanceof Nop){
			code3.Add(new Quadruplet(OP.NOP,"_","_","_"));
		}
		if(c.cmd instanceof Affect){
			(c.cmd as Affect).compile();
			}
		//println(code3.toString());
		return code3.toString();
	}
	
	def compile(Affect a){
		val size=a.vars.size;
		for(var i=0;i<size;i++){
			code3.Add(new Quadruplet(OP.AFF,a.vars.get(i),a.exprs.get(i).compile(), "_"));
			fonction.addVariable(a.vars.get(i), VarType.local);
		}
	}
	
	def compile(Expr e){
		if(e instanceof ExprSimple){
			return (e as ExprSimple).compile();
		}
	}
	def compile(ExprSimple e){
		if(e.nameFunction!==null){
			return '('+e.nameFunction+" "+e.vars.compile()+')';
		}
		else if(e.sym!==null){
//			symtab.addSymbol(e.toString);
			return ""+e.sym;
		}
		else if(e.varSimple!==null){
//			fonction.addVariable(e.toString, VarType.local);
			return ""+e.varSimple;
		}
		else{
			return e.str;
		}
	}
	
	
}




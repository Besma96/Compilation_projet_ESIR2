/*
 * generated by Xtext 2.15.0
 */
package org.xtext.compilation.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.compilation.while_l.Affect
import org.xtext.compilation.while_l.Command
import org.xtext.compilation.while_l.Commands
import org.xtext.compilation.while_l.Expr
import org.xtext.compilation.while_l.ExprAnd
import org.xtext.compilation.while_l.ExprCons
import org.xtext.compilation.while_l.ExprEq
import org.xtext.compilation.while_l.ExprHd
import org.xtext.compilation.while_l.ExprList
import org.xtext.compilation.while_l.ExprNot
import org.xtext.compilation.while_l.ExprOr
import org.xtext.compilation.while_l.ExprSimple
import org.xtext.compilation.while_l.ExprSym
import org.xtext.compilation.while_l.ExprTl
import org.xtext.compilation.while_l.For
import org.xtext.compilation.while_l.Function
import org.xtext.compilation.while_l.If
import org.xtext.compilation.while_l.Nop
import org.xtext.compilation.while_l.Program
import org.xtext.compilation.while_l.While

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class While_lGenerator extends AbstractGenerator {

//int nbfunctions=0;
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
	}
	def doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context,
					String name_file,int global_indent,int if_indent,int for_indent,
					int while_indent,int aff_indent
	)
	{
		for(r:resource.allContents.toIterable.filter(Program)){
			fsa.generateFile(name_file,r.compile(global_indent,if_indent,for_indent,while_indent,
							 aff_indent
			))	
		}
	}
	
	def compile(Program p,int global_indent,int if_indent,int for_indent,int while_indent,
				int aff_indent
	){
		'''
		«FOR f:p.functions»
		«f.compile(global_indent,if_indent,for_indent,while_indent,aff_indent)»	
		«ENDFOR»
		'''
		
	}
	def compile(Function f,int global_indent,int if_indent,int for_indent,int while_indent,
				int aff_indent
	){
		
		'''
			function «f.name»:
			read «FOR e: f.definition.input.vars SEPARATOR ','»«e»«ENDFOR»
			%
			«f.definition.commands.compile(global_indent,if_indent,for_indent,while_indent,aff_indent)»
			%
			write «FOR e: f.definition.output.vars SEPARATOR ','»«e»«ENDFOR»
			
		'''
		

	}
	def compile(Commands cs,int global_indent,int if_indent,int for_indent,int while_indent,int aff_indent
	)
	{
		var size=cs.commands.size;
		var res="";
		for(Command c :cs.commands)
		{
			if(size==1)
			{
				res+=c.compile(global_indent,if_indent,for_indent,while_indent,aff_indent)+"";	
			}
			else
			{
				res+=c.compile(global_indent,if_indent,for_indent,while_indent,aff_indent)+";\n";
				size--;
			}
		}
	return res; 
	}
	def compile(Command c,int global_indent,int if_indent,int for_indent,int while_indent,int aff_indent
	)
	{
		if(c.cmd instanceof If){
			
			var indentation="";
			for(var i=0;i<(global_indent+if_indent);i++){
				indentation+="\t";
			}
			
		if((c.cmd as If).commands2 !== null){
			return indentation+"if"+(c.cmd as If).expr.compile
			+"then\n"+(c.cmd as If).commands1.compile(global_indent,
						if_indent,for_indent,while_indent,aff_indent)+"\n"+indentation
						+"else\n"+(c.cmd as If).commands2.compile(global_indent,if_indent,for_indent,while_indent,
							aff_indent)+"\n"+indentation+"fi";
						}
		else{
			return indentation+"if"+(c.cmd as If).expr.compile+"then\n"+(c.cmd as If).commands1.compile(global_indent,
						if_indent,for_indent,while_indent,aff_indent)+"\n"+indentation+"fi";
		}
			
		}
		if(c.cmd instanceof For){
			var indentation="";
			for(var i=0;i<(global_indent+for_indent);i++){
				indentation+="\t";
			}
		return indentation+"for "+(c.cmd as For).expr.compile+" do\n"+(c.cmd as For).cmds.compile(global_indent,if_indent,for_indent,while_indent										
									,aff_indent)+"\n"+indentation+"od";
		
		}
		if(c.cmd instanceof While){
			var indentation="";
			for(var i=0;i<(global_indent+while_indent);i++){
				indentation+="\t";
			}
		return indentation+"while "+(c.cmd as While).expr.compile
									+" do\n"+(c.cmd as While).cmds.compile(global_indent,if_indent,for_indent,while_indent,
										aff_indent)+"\n"+indentation+"od";
			
		}
		if(c.cmd instanceof Nop){
			return "nop";
		}
		if( c.cmd instanceof Affect){
		var indentation="";
			for(var i=0;i<(global_indent+aff_indent);i++){
				indentation+="\t";
			}
		return indentation+(c.cmd as Affect).compile;
		
		}
	}
	
	def compile (Affect v)
	{
	val size_vars=v.vars.size;
		if(size_vars==1){
			return v.vars.get(0)+" := "+v.exprs.get(0).compile;
		}
		else
		{
			var res="";
			for(var i=0;i<size_vars-1;i++){
				res+=v.vars.get(i)+' ,';
			}
			res+=v.vars.get(size_vars-1)+" := ";
			
			val size_exprs=v.exprs.size;
			for(var i=0;i<size_exprs-1;i++){
				res+=v.exprs.get(i).compile+" ,";
			}
			res+=v.exprs.get(size_exprs-1).compile;
			return res;
		}
	}
	def compile (Expr e){
		if(e.expr instanceof ExprAnd){
		return (e.expr as ExprAnd).arg1.compile+"and"+(e.expr as ExprAnd).arg2.compile;
		}
		if(e.expr instanceof ExprOr){
		return (e.expr as ExprOr).arg1.compile+"or"+(e.expr as ExprOr).arg2.compile;
		}
		if(e.expr instanceof ExprSimple){
			return (e.expr as ExprSimple).compile
		}
		if(e.expr instanceof ExprCons){
			return "("+"cons"+(e.expr as ExprCons).arg1.compile+(e.expr as ExprCons).arg2.compile+")"
		}
		if(e.expr instanceof ExprList){
			val size=(e.expr as ExprList).arg.size;
			if(size==1){
			return "("+"list"+(e.expr as ExprList).arg.get(0).compile+")";	
			}
			else
			{
			var res="("+"list";
			for(var i=0;i<size-1;i++){
				res+=(e.expr as ExprList).arg.get(i).compile+"; à completer"
			}
			res+=(e.expr as ExprList).arg.get(size-1).compile+")"
			(e.expr as ExprList).arg.get(0).compile
			}	
		}
		if(e.expr instanceof ExprHd){
			"("+"hd"+(e.expr as ExprHd).arg.compile+")";
		}
		if(e.expr instanceof ExprTl){
			"("+"Tl"+(e.expr as ExprTl).arg.compile+ ')';
		}
		if(e.expr instanceof ExprSym){
			val size=(e.expr as ExprSym).arg2.size;
			if(size==1){
				return "("+(e.expr as ExprSym).arg1+(e.expr as ExprSym).arg2.get(0).compile+")";
			}
			else
			{
				var res="("+(e.expr as ExprSym).arg1;
				for(var i=0;i<size-1;i++){
					res+=(e.expr as ExprSym).arg2.get(i).compile+"à completé";
				}
				res+=(e.expr as ExprSym).arg2.get(size-1).compile+")";
				return res;	
			}
			
		}
		if(e.expr instanceof ExprNot){
			return "not"+(e.expr as ExprNot).arg1.compile;
		}
	}
	def compile(ExprSimple e){
		if(e.nameFunction!==null){
			return null
		}
	}
	def compile(ExprEq e){
		return e.arg1.compile+"=?"+e.arg2.compile;
	}

		
}